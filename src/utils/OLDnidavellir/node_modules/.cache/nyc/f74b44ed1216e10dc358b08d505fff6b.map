{"version":3,"file":"tests.cjs.js","sources":["../src/utils/require.js","../src/utils/uintArray.js","../src/utils/hash.js","../src/utils/base.js","../src/hd/paths.js","../src/networks/baseInfo.js","../src/networks/bitcoin.js","../src/core/networkInfo.js","../src/utils/formatter.js","../src/utils/secp256k1.js","../src/core/privateKey.js","../src/hd/private.js","../src/hd/public.js","../test/hd/derive.js","../src/hd/path.js","../src/hd/derive.js","../src/hd/extendedKey.js","../test/hd/extendedKey.js","../src/hd/hdKey.js","../test/hd/hdKey.js","../test/hd/path.js"],"sourcesContent":["const lazyHandler = activeModule => ({\n  get: (target, prop, receiver) => {\n    // If already loaded return the loaded module\n    if (activeModule) return activeModule[prop]\n    // Try to inject the loaded module\n    if (prop === 'inject') {\n      return loadedModule => {\n        activeModule = loadedModule\n        for (const prop in target) {\n          target[prop].inject(activeModule[prop])\n        }\n      }\n    }\n    // Create a new child proxy if this prop not yet exists\n    if (!target[prop]) {\n      target[prop] = new Proxy(function (...args) {\n        if (!activeModule) target()\n        return activeModule[prop](...args)\n      }, lazyHandler())\n    }\n    return target[prop]\n  }\n})\n\nexport const lazify = unsafeModule => {\n  const parentModule = function (injectedModule = {}, loadUnsafe = true) {\n    const defaultModule = loadUnsafe ? unsafeModule() : {}\n    const loadedModule = Object.assign(defaultModule, injectedModule)\n    parentProxy.inject(loadedModule)\n  }\n  const parentProxy = new Proxy(parentModule, lazyHandler())\n  return parentProxy\n}\n","// @flow\n\nexport const isHexString = (hex: string) =>\n  typeof hex === 'string' && /^[0-9a-f]*$/i.test(hex)\n\nexport const toUint8Array = (hexString: string): Uint8Array => {\n  if (!isHexString(hexString)) {\n    throw new Error(`${hexString} is Not a Hex string`)\n  }\n  if (hexString.length % 2 !== 0) hexString = `0${hexString}`\n  const hex = hexString.match(/.{1,2}/g) || []\n  const bytes = hex.map(byte => parseInt(byte, 16))\n  return new Uint8Array(bytes)\n}\n\nexport const fromUint8Array = (bytes: Uint8Array): string =>\n  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')\n","// @flow\n\nimport { type Hashes, type SplittedHmac } from '../../types/utils.js'\nimport { lazify } from './require.js'\nimport { fromUint8Array, toUint8Array } from './uintArray.js'\n\nexport const hashjs: Hashes<Uint8Array> = (lazify(() =>\n  require('hash.js')\n): any)\n\nexport const digest = (hash: Function) => (data: string) => {\n  const uintArray = toUint8Array(data)\n  const rawRes = hash()\n    .update(uintArray)\n    .digest()\n  const resArray = new Uint8Array(rawRes)\n  return fromUint8Array(resArray)\n}\n\nexport const digestHmac = (hmac: Function, hash: Function) => (\n  data: string,\n  key: string\n) => {\n  const uintKey = toUint8Array(key)\n  const hmacHash = () => hmac(hash, uintKey)\n  return digest(hmacHash)(data)\n}\n\nexport const sha256 = digest(hashjs.sha256)\nexport const sha512 = digest(hashjs.sha512)\nexport const ripemd160 = digest(hashjs.ripemd160)\nexport const sha512Hmac = digestHmac(hashjs.hmac, hashjs.sha512)\n\nexport const hash256 = (data: string) => sha256(sha256(data))\nexport const hash160 = (data: string) => ripemd160(sha256(data))\nexport const hmacSplit = (key: string, data: string): SplittedHmac => {\n  const hash = sha512Hmac(key, data)\n  const left = hash.slice(0, 64)\n  const right = hash.slice(64, 128)\n  return { left, right }\n}\n","// @flow\n\nimport { Buffer } from 'buffer'\n\nimport basex from 'base-x'\n\nimport {\n  type Alphabet,\n  type BaseCheck,\n  type BaseDecoder,\n  type Bases,\n  type HashFunction\n} from '../../types/utils.js'\nimport { hash256 } from './hash.js'\n\n// The default ALPHABETS, the name of the base codec will be the alphabet's length\nexport const ALPHABETS: Array<Alphabet> = [\n  '01',\n  '01234567',\n  '0123456789a',\n  '0123456789abcdef',\n  '0123456789ABCDEFGHJKMNPQRSTVWXYZ',\n  '0123456789abcdefghijklmnopqrstuvwxyz',\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',\n  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n]\n\nexport const createCheckSumBase = (\n  base: BaseDecoder,\n  hashFunc?: HashFunction<string>\n): BaseDecoder => ({\n  encode: (hexStr: string): string => {\n    const checksum = (hashFunc || hash256)(hexStr)\n    const checkHex = `${hexStr}${checksum.slice(0, 8)}`\n    return base.encode(checkHex)\n  },\n  decode: (baseString: string): string => {\n    const hexStr = base.decode(baseString)\n    const payload = hexStr.slice(0, -8)\n    const newChecksum = (hashFunc || hash256)(payload)\n    const checksum = hexStr.slice(-8)\n    if (newChecksum.startsWith(checksum)) return payload\n    throw new Error('Invalid checksum')\n  }\n})\n\nexport const createHexEncoder = (\n  base: BaseDecoder,\n  hashFunc?: HashFunction<string>\n): BaseCheck => {\n  const newBase = { ...base }\n  const encode: (buf: Buffer) => string = newBase.encode\n  const decode: (str: string) => Buffer = newBase.decode\n  newBase.encode = a => encode(Buffer.from(a, 'hex'))\n  newBase.decode = a => decode(a).toString('hex')\n  return { ...newBase, check: createCheckSumBase(newBase, hashFunc) }\n}\n\nexport const base: Bases = ALPHABETS.reduce((decoders, alphabet) => {\n  const baseDecoder = createHexEncoder(basex(alphabet))\n  return { ...decoders, [alphabet.length]: baseDecoder }\n}, {})\n","// @flow\n\nimport { type HDPathSetting, type HDPathsSetting } from '../../types/core'\nimport { base } from '../utils/base.js'\n// TODO - Actually get bech32\nconst bech32 = base['58'].check\nconst base58 = base['58'].check\n\nconst BasePath: HDPathSetting = {\n  scriptType: 'P2PKH',\n  xpriv: { prefix: 0x0488ade4, stringPrefix: 'xprv', decoder: { base: 'xprv', ...base58 } },\n  xpub: { prefix: 0x0488b21e, stringPrefix: 'xpub', decoder: { base: 'xpub', ...base58 } },\n  address: { prefix: 0x80, stringPrefix: '1', decoder: { base: '1', ...base58 } }\n}\n\nconst SupportedPaths: HDPathsSetting = {\n  '32': BasePath,\n  '44': BasePath,\n  '49': {\n    scriptType: 'P2WPKH-P2SH',\n    xpriv: { prefix: 0x049d7878, stringPrefix: 'yprv', decoder: base58 },\n    xpub: { prefix: 0x049d7cb2, stringPrefix: 'ypub', decoder: base58 },\n    address: { prefix: 0x05, stringPrefix: '3', decoder: base58 }\n  },\n  '84': {\n    scriptType: 'P2WPKH',\n    xpriv: { prefix: 0x04b2430c, stringPrefix: 'zprv', decoder: base58 },\n    xpub: { prefix: 0x04b24746, stringPrefix: 'zpub', decoder: base58 },\n    address: { prefix: -1, stringPrefix: 'bc', decoder: bech32 }\n  }\n}\n\nexport default SupportedPaths\n","// @flow\n\nimport { type NetworkInfo } from '../../types/core.js'\nimport Paths from '../hd/paths.js'\nimport { base } from '../utils/base.js'\nimport { hash256 } from '../utils/hash.js'\n\nexport const main: NetworkInfo = {\n  coinType: 0,\n  wif: {\n    prefix: 0x80,\n    stringPrefix: '1',\n    decoder: base['58'].check\n  },\n  HDPaths: { '32': Paths['32'], '44': Paths['44'] },\n  DefaultHDPath: 44,\n  txHash: hash256,\n  sigHash: (str: Buffer) => Buffer.from(hash256(str.toString('hex')), 'hex')\n}\n","// @flow\n\nimport Paths from '../hd/paths.js'\n\nexport const main = {\n  HDPaths: { '49': Paths['49'], '84': Paths['84'] },\n  DefaultHDPath: 84\n}\n\nexport const testnet = {\n  coinType: 1,\n  wif: 0xef,\n  HDPaths: {\n    '32': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0x6f\n    },\n    '44': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0x6f\n    },\n    '49': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0xc4\n    },\n    '84': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 'tb'\n    }\n  }\n}\n","// @flow\n\nimport {\n  type HDPathSetting,\n  type NetworkInfo,\n  type NetworkInfos,\n  type NewNetworks\n} from '../../types/core.js'\nimport { main } from '../networks/baseInfo.js'\nimport * as Networks from '../networks/networks.js'\n\nexport const createInfo = (info: $Shape<NetworkInfo>): NetworkInfo => {\n  const newNetwork: NetworkInfo = ({}: any)\n\n  for (const set in main) {\n    const mainSet = main[set]\n    const infoSet = info[set]\n\n    if (Array.isArray(mainSet)) {\n      newNetwork[set] = (infoSet || [])\n        .concat(mainSet)\n        .filter((v, i, s) => s.indexOf(v) === i)\n    } else if (typeof mainSet === 'object') {\n      newNetwork[set] = { ...mainSet, ...(infoSet || {}) }\n    } else if (typeof infoSet !== 'undefined') {\n      newNetwork[set] = infoSet\n    } else newNetwork[set] = mainSet\n  }\n\n  return newNetwork\n}\n\nexport const createNetworks = (newInfos: NewNetworks) => {\n  const networks = { main }\n  for (const network in newInfos) {\n    const infos = newInfos[network]\n    for (const networkType in infos) {\n      const partialInfo = infos[networkType]\n      let name = network\n      if (networkType !== 'main') name += networkType.toLowerCase()\n      networks[name] = createInfo(partialInfo)\n    }\n  }\n  return networks\n}\n\nexport const networks: NetworkInfos = createNetworks(Networks)\n\nexport const addNetworks = (newInfos: NewNetworks) =>\n  Object.assign(networks, createNetworks(newInfos))\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\nexport const getHDSetting = (value: any, network?: string): HDPathSetting => {\n  // If no network is specified, check all available networks\n  if (!network) {\n    for (const network in networks) {\n      try {\n        return getHDSetting(value, network)\n      } catch (e) {}\n    }\n    throw new Error('Unknown prefix')\n  }\n\n  const { HDPaths } = networks[network]\n  for (const purpose in HDPaths) {\n    const hdPath = HDPaths[purpose]\n    for (const key in hdPath) {\n      const setting = hdPath[key]\n      // checking if address that has legacy\n      if (Array.isArray(setting)) {\n        return setting.find(\n          ({ prefix, stringPrefix }) =>\n            prefix === value || stringPrefix === value\n        )\n      }\n\n      // checking if xpub, xpriv, or address\n      if (\n        typeof setting === 'object' &&\n        (setting.prefix === value || setting.stringPrefix === value)\n      ) {\n        return hdPath\n      }\n\n      // if scriptType or purpose\n      if (setting === value) return hdPath\n    }\n  }\n  throw new Error(`Wrong value: ${value} for network: ${network}`)\n}\n\nexport const getDecoder = (network: string, value: any) => {\n  const hdPath = getHDSetting(value, network)\n  for (const key in hdPath) {\n    const decoder = hdPath[key]\n\n    if (Array.isArray(decoder)) {\n      return decoder.find(\n        ({ prefix, stringPrefix }) =>\n          prefix === value || stringPrefix === value\n      )\n    }\n\n    if (decoder.prefix === value || decoder.stringPrefix === value) {\n      return decoder.decoder\n    }\n  }\n  throw new Error(`Wrong value: ${value} for network: ${network}`)\n}\n","// @flow\n\nimport { type FunctionFormatterOptions } from '../../types/utils.js'\nimport { fromUint8Array, toUint8Array } from './uintArray.js'\n\nexport const formatFunction = (\n  func: Function,\n  opts?: FunctionFormatterOptions = {}\n) => {\n  const { numParams = 1, encoder, results = [], sync } = opts\n  const { input = toUint8Array, output = fromUint8Array } = encoder || {}\n\n  const encode = (i: number, cps = a => a) => {\n    if (!i--) return cps\n    const newCps = (p: any) => {\n      p[i] = input(p[i])\n      return cps(p)\n    }\n    return encode(i, newCps)\n  }\n\n  const paramEncoder = encode(numParams)\n\n  let encodeResult = (res: any) => output(res)\n  if (!results) {\n    encodeResult = (res: any) => res\n  } else if (results.length) {\n    encodeResult = (res: any) => {\n      for (const param of results) {\n        res[param] = output(res[param])\n      }\n      return res\n    }\n  }\n\n  let waitResult = async (res: any) => {\n    res = await res\n    return encodeResult(res)\n  }\n  if (sync) waitResult = (res: any) => encodeResult(res)\n\n  return (...params: any): any => {\n    const result = func(...paramEncoder(params))\n    return waitResult(result)\n  }\n}\n\nexport const formatByteSize = (\n  originalByteSize: number,\n  newByteSize: number,\n  pad: boolean = originalByteSize > newByteSize\n) => (data: Array<number>) => {\n  let acc = 0\n  let bits = 0\n  const ret = []\n  const maxNum = (1 << newByteSize) - 1\n  for (let p = 0; p < data.length; ++p) {\n    const value = data[p]\n    if (value < 0 || value >> originalByteSize !== 0) {\n      throw new Error('Wrong bit value')\n    }\n    acc = (acc << originalByteSize) | value\n    bits += originalByteSize\n    while (bits >= newByteSize) {\n      bits -= newByteSize\n      ret.push((acc >> bits) & maxNum)\n    }\n  }\n  if (pad && bits > 0) {\n    ret.push((acc << (newByteSize - bits)) & maxNum)\n  } else if (\n    bits >= originalByteSize ||\n    (acc << (newByteSize - bits)) & maxNum\n  ) {\n    throw new Error('Wrong bit value')\n  }\n  return ret\n}\n","// @flow\n\nimport { type Secp256k1 } from '../../types/utils.js'\nimport { formatFunction } from './formatter.js'\nimport { lazify } from './require.js'\n\nexport const secp256k1: Secp256k1<Uint8Array> = (lazify(() =>\n  require('secp256k1')\n): any)\n\nconst encoder = {\n  input: a => Buffer.from(a, 'hex'),\n  output: a => a.toString('hex')\n}\n\nexport const publicKeyCreate = formatFunction(secp256k1.publicKeyCreate, {\n  encoder\n})\nexport const signatureNormalize = formatFunction(secp256k1.signatureNormalize, {\n  encoder\n})\nexport const signatureExport = formatFunction(secp256k1.signatureExport, {\n  encoder\n})\nexport const privateKeyTweakAdd = formatFunction(secp256k1.privateKeyTweakAdd, {\n  encoder,\n  numParams: 2\n})\nexport const publicKeyTweakAdd = formatFunction(secp256k1.publicKeyTweakAdd, {\n  encoder,\n  numParams: 2\n})\nexport const verify = formatFunction(secp256k1.verify, {\n  encoder,\n  numParams: 3,\n  results: null\n})\nexport const signature = formatFunction(secp256k1.sign, {\n  encoder,\n  numParams: 2,\n  results: ['signature']\n})\n\nexport const sign = (message: string, privateKey: string) =>\n  signature(message, privateKey)\n    .then(({ signature }) => signature)\n    .then(signatureNormalize)\n    .then(signatureExport)\n","// @flow\n\nimport { networks } from './networkInfo.js'\nimport {\n  publicKeyCreate,\n  sign as Sign,\n  verify as Verify\n} from '../../src/utils/secp256k1.js'\n\nexport const fromWIF = (\n  wif: string,\n  network: string = 'main'\n): { privateKey: string, compress: boolean } => {\n  const { prefix, decoder } = networks[network].wif\n  const keyHex = decoder.decode(wif)\n  if (parseInt(keyHex.slice(0, 2), 16) !== prefix) {\n    throw new Error(\n      `Unknown key prefix ${keyHex.slice(0, 2)} for network ${network}`\n    )\n  }\n  const privateKey = keyHex.slice(2, 66)\n  let compress = false\n  if (keyHex.length >= 68) {\n    if (parseInt(keyHex.slice(66, 68), 16) !== 1) {\n      throw new Error(`Unknown compression flag ${keyHex.slice(66, 68)}`)\n    }\n    compress = true\n  }\n  return { privateKey, compress }\n}\n\nexport const toWIF = (\n  privateKey: string,\n  network: string = 'main',\n  compress: boolean = true\n): string => {\n  if (privateKey.length !== 64) throw new Error(`Wrong key length`)\n  const { prefix, decoder } = networks[network].wif\n  const prefixStr = prefix.toString(16)\n  const compressFlag = compress ? '01' : ''\n  const hexKey = `${prefixStr}${privateKey}${compressFlag}`\n  return decoder.encode(hexKey)\n}\n\nexport const toPublic = async (\n  privateKey: string,\n  compress: boolean = true\n): Promise<string> => publicKeyCreate(privateKey, compress)\n\nexport const sign = async (privateKey: string, msg: string): Promise<string> => Sign(msg, privateKey)\n\nexport const verify = async (\n  msg: string,\n  signature: string,\n  publicKey?: string,\n  privateKey?: string\n): Promise<Boolean> => {\n  if (!publicKey) {\n    if (!privateKey) throw new Error('Cannot verify without keys.')\n    publicKey = await publicKeyCreate(privateKey, true)\n  }\n  const verified = await Verify(msg, signature, publicKey)\n  return verified\n}\n","// @flow\n\nimport { getHDSetting, getDecoder } from '../core/networkInfo.js'\nimport { type SplittedHmac } from '../../types/utils.js'\nimport { type DerivedPrivateKey, type ExtendedPrivateKey, type ExtendedData } from '../../types/hd.js'\nimport { hmacSplit } from '../utils/hash.js'\n// import { hmacSplit, hash160 } from '../utils/hash.js'\nimport { toPublic } from '../core/privateKey.js'\nimport { privateKeyTweakAdd } from '../utils/secp256k1'\n\nexport const HARDENED = 0x80000000\nexport const MAX_INDEX = 0xffffffff\nexport const MAX_DEPTH = 0xff\nexport const TWEAK_OUT_OF_RANGE_ERROR = 'tweak out of range'\nexport const SEED = '426974636f696e2073656564'\n\nexport const dataToHex = (data: ExtendedData): string => {\n  return (\n    data.version.toString(16).padStart(8, '0') +\n    data.depth.toString(16).padStart(2, '0') +\n    data.parentFingerPrint.toString(16).padStart(8, '0') +\n    data.childNumber.toString(16).padStart(8, '0') +\n    data.chainCode\n  )\n}\n\nexport const dataFromHex = (keyHex: string, network?: string): ExtendedData => {\n  // Check the entire hex length\n  if (keyHex.length !== 156) throw new Error('Wrong key length')\n\n  // Check that the key prefix matches the network's prefix if given a network\n  const version = parseInt(keyHex.slice(0, 8), 16)\n  if (network) {\n    const setting = getHDSetting(version, network)\n    if (!setting) throw new Error('Wrong extended key version for network')\n  }\n  return {\n    version,\n    depth: parseInt(keyHex.slice(9, 10), 16),\n    parentFingerPrint: parseInt(keyHex.slice(10, 18), 16),\n    childNumber: parseInt(keyHex.slice(18, 26), 16),\n    chainCode: keyHex.slice(26, 90)\n  }\n}\n\nexport const getTweak = async (\n  key: string,\n  chainCode: string,\n  index: number\n): Promise<SplittedHmac> => {\n  if (index > MAX_INDEX) throw new Error('Index out of range.')\n  key += index.toString(16).padStart(8, '0')\n  return hmacSplit(key, chainCode)\n}\n\nexport const fromSeed = async (\n  seed: string,\n  version: number = 0x0488b21e\n): Promise<ExtendedPrivateKey & { publicKey: string }> => {\n  const { left, right } = hmacSplit(seed, SEED)\n  const publicKey = await toPublic(left, true)\n  return {\n    privateKey: left,\n    publicKey,\n    chainCode: right,\n    childNumber: 0,\n    parentFingerPrint: 0,\n    version,\n    depth: 0\n  }\n}\n\n// export const fromIndex = async (\n//   parentKeys: ExtendedPrivateKey,\n//   index: string\n// ): Promise<ExtendedPrivateKey> => {\n//   if (parentKeys.depth >= MAX_DEPTH) throw new Error('Depth too high.')\n\n//   const { privateKey, chainCode } = parentKeys\n//   const derivedKeyPair: DerivedPrivateKey = await derive(privateKey, index, chainCode)\n//   if (!parentKeys.publicKey) {\n//     parentKeys.publicKey = await toPublic(parentKeys.privateKey, true)\n//   }\n//   const parentFingerPrint = await hash160(parentKeys.publicKey)\n\n//   return {\n//     ...derivedKeyPair,\n//     parentFingerPrint: parseInt(parentFingerPrint.slice(0, 8), 16),\n//     version: parentKeys.version,\n//     depth: parentKeys.depth + 1\n//   }\n// }\n\nexport const derive = async (\n  privateKey: string,\n  index: number,\n  chainCode: string,\n  hardened: boolean = false,\n  publicKey?: string\n): Promise<DerivedPrivateKey> => {\n  if (hardened && index < HARDENED) index += HARDENED\n  let key = `00${privateKey}`\n  if (index < HARDENED) {\n    key = publicKey || await toPublic(privateKey, true)\n  }\n\n  try {\n    const { left, right } = await getTweak(key, chainCode, index)\n    const childKey = await privateKeyTweakAdd(privateKey, left)\n    return { privateKey: childKey, childNumber: index, chainCode: right }\n  } catch (e) {\n    if (!e.message.includes(TWEAK_OUT_OF_RANGE_ERROR)) throw e\n    if (index > MAX_INDEX) index -= HARDENED\n    return derive(privateKey, index + 1, chainCode, hardened, publicKey)\n  }\n}\n\nexport const fromHex = (keyHex: string, network?: string): ExtendedPrivateKey => {\n  // Get the byte which tells us what type of key we're expecting\n  const headerByte = parseInt(keyHex.slice(90, 92), 16)\n  if (headerByte !== 0) throw new Error('Wrong private key header')\n\n  return {\n    privateKey: keyHex.slice(92, 156),\n    ...dataFromHex(keyHex, network)\n  }\n}\n\nexport const toHex = (key: ExtendedPrivateKey): string =>\n  dataToHex(key) + `00${key.privateKey}`\n\nexport const fromString = (\n  hdKey: string,\n  network: string = 'main'\n): ExtendedPrivateKey => {\n  const keyHex = getDecoder(network, hdKey.slice(0, 4)).decode(hdKey)\n  return fromHex(keyHex, network)\n}\nexport const toString = (\n  hdKey: ExtendedPrivateKey,\n  network: string = 'main'\n): string => getDecoder(network, hdKey.version).encode(toHex(hdKey))\n","// @flow\n\nimport { getDecoder } from '../core/networkInfo.js'\nimport { HARDENED, TWEAK_OUT_OF_RANGE_ERROR, getTweak, dataFromHex, dataToHex } from './private.js'\nimport { type DerivedPublicKey, type ExtendedPublicKey } from '../../types/hd.js'\nimport { publicKeyTweakAdd } from '../utils/secp256k1'\n\nexport const derive = async (\n  publicKey: string,\n  index: number,\n  chainCode: string\n): Promise<DerivedPublicKey> => {\n  if (index >= HARDENED) {\n    throw new Error('Cannot derive a hardened index with a public key.')\n  }\n\n  try {\n    const { left, right } = await getTweak(publicKey, chainCode, index)\n    const childKey = await publicKeyTweakAdd(publicKey, left, true)\n    return { publicKey: childKey, childNumber: index, chainCode: right }\n  } catch (e) {\n    if (!e.message.includes(TWEAK_OUT_OF_RANGE_ERROR)) throw e\n    return derive(publicKey, index + 1, chainCode)\n  }\n}\n\nexport const fromHex = (keyHex: string, network?: string): ExtendedPublicKey => {\n  // Get the byte which tells us what type of key we're expecting\n  const headerByte = parseInt(keyHex.slice(90, 92), 16)\n  if (headerByte !== 2 || headerByte !== 3) throw new Error('Wrong public key header')\n\n  return {\n    publicKey: keyHex.slice(90, 156),\n    ...dataFromHex(keyHex, network)\n  }\n}\n\nexport const toHex = (key: ExtendedPublicKey): string =>\n  dataToHex(key) + key.publicKey\n\nexport const fromString = (\n  hdKey: string,\n  network: string = 'main'\n): ExtendedPublicKey => {\n  const keyHex = getDecoder(network, hdKey.slice(0, 4)).decode(hdKey)\n  return fromHex(keyHex, network)\n}\n\nexport const toString = (\n  hdKey: ExtendedPublicKey,\n  network: string = 'main'\n): string => getDecoder(network, hdKey.version).encode(toHex(hdKey))\n","// @flow\n\nimport { assert } from 'chai'\nimport { describe, it } from 'mocha'\n\nimport * as Private from '../../src/hd/private.js'\nimport * as Public from '../../src/hd/public.js'\nimport fixtures from './fixtures/derive.json'\n\nconst deriveFixtures = fixtures\n\ndescribe('Testing Key derivation', function () {\n  deriveFixtures.private.forEach(test => {\n    it(`Deriving private key without public key ${test[0]} for index ${\n      test[2]\n    }`, async function () {\n      const privateKey = test[0]\n      const chainCode = test[1]\n      const index = test[2]\n      const expectedChildKey = {\n        privateKey: test[3],\n        chainCode: test[4],\n        childNumber: test[5]\n      }\n      const hardened = test[6]\n      const childKey = await Private.derive(\n        privateKey,\n        index,\n        chainCode,\n        hardened\n      )\n      assert.deepEqual(childKey, expectedChildKey)\n    })\n  })\n\n  deriveFixtures.privateWithPublic.forEach(test => {\n    it(`Deriving private key with public key ${test[0]} for index ${\n      test[2]\n    }`, async function () {\n      const privateKey = test[0]\n      const chainCode = test[1]\n      const index = test[2]\n      const expectedChildKey = {\n        privateKey: test[3],\n        chainCode: test[4],\n        childNumber: test[5]\n      }\n      const publicKey = test[6]\n      const childKey = await Private.derive(\n        privateKey,\n        index,\n        chainCode,\n        false,\n        publicKey\n      )\n      assert.deepEqual(childKey, expectedChildKey)\n    })\n  })\n\n  deriveFixtures.public.forEach(test => {\n    it(`Deriving public key ${test[0]} for index ${test[2]}`, async function () {\n      const publicKey = test[0]\n      const chainCode = test[1]\n      const index = test[2]\n      const expectedChildKey = {\n        publicKey: test[3],\n        chainCode: test[4],\n        childNumber: test[5]\n      }\n      const childKey = await Public.derive(\n        publicKey,\n        index,\n        chainCode\n      )\n      assert.deepEqual(childKey, expectedChildKey)\n    })\n  })\n})\n","// @flow\n\nimport { type HDPath, type Bip32Path, type Bip44Path } from '../../types/hd.js'\nimport { HARDENED, MAX_INDEX } from './private.js'\nimport { networks } from '../core/networkInfo.js'\n\nexport const parseToken = (token: string): number => {\n  // Check for hardened flag\n  const hardened = token[token.length - 1] === '\\''\n  // If hardened, we need to add the HARDENED param to the token\n  const num = hardened\n    ? parseInt(token.slice(0, -1)) + HARDENED\n    : parseInt(token)\n  return num\n}\n\nexport const stringifyToken = (token: number, harden: boolean = false): string => {\n  if (token >= HARDENED) {\n    harden = true\n    token = token - HARDENED\n  }\n  return harden ? `${token}'` : `${token}`\n}\n\nexport const verify = (index: string | Array<string>): boolean => {\n  // If it's an array, check each index and return true only if non failed\n  if (Array.isArray(index)) return !!index.map(verify)\n  // If it's a full path, split it then check\n  if (index.includes('/')) return verify(index.split('\\''))\n  // Return true if it's the master index\n  if (index === 'm') return true\n  if (parseToken(index) > MAX_INDEX) throw new Error(`Index out of range: ${index}`)\n  return true\n}\n\nexport const fromString = (path: string): Array<string> => {\n  try {\n    const pathArr = path.split('/')\n    verify(pathArr)\n    return pathArr\n  } catch (e) {\n    e.message = `Bad path: ${path}\\n\\t${e.message}`\n    throw e\n  }\n}\n\nexport const toString = (path: Array<string>): string => {\n  try {\n    verify(path)\n    return path.join('/')\n  } catch (e) {\n    e.message = `Bad path: ${JSON.stringify(path)}\\n\\t${e.message}`\n    throw e\n  }\n}\n\nexport const parse = (path: string): Array<number> => {\n  const pathArr = fromString(path)\n  if (pathArr[0] === 'm') pathArr.shift()\n  return pathArr.map(parseToken)\n}\n\nexport const Bip32 = {\n  toString: ({ account, chain, index }: Bip32Path): string => {\n    if (chain !== 0 && chain !== 1) throw new Error('Unknown chain')\n    return toString([\n      'm',\n      stringifyToken(account),\n      stringifyToken(chain),\n      stringifyToken(index)\n    ])\n  },\n  fromString: (path: string): Bip32Path => {\n    const pathArr = fromString(path)\n    if (pathArr.length !== 4) throw new Error('Unknown path depth')\n    if (pathArr[0] !== 'm') throw new Error('Unknown path header')\n    const chain = parseToken(pathArr[2])\n    if (chain !== 0 && chain !== 1) throw new Error('Unknown chain')\n    return {\n      account: parseToken(pathArr[1]),\n      index: parseToken(pathArr[3]),\n      chain\n    }\n  }\n}\n\nexport const Bip44 = {\n  toString: ({ purpose, coinType, account, change, index }: Bip44Path): string => {\n    if (change !== 0 && change !== 1) throw new Error('Unknown chain')\n    if (index >= HARDENED) throw new Error(`Index should be smaller then ${HARDENED}`)\n    return toString([\n      'm',\n      stringifyToken(purpose, true),\n      stringifyToken(coinType, true),\n      stringifyToken(account, true),\n      stringifyToken(change),\n      stringifyToken(index)\n    ])\n  },\n  fromString: (path: string): Bip44Path => {\n    const pathArr = fromString(path)\n    if (pathArr.length !== 6) throw new Error('Unknown path depth')\n    if (pathArr[0] !== 'm') throw new Error('Unknown path header')\n    const purpose = parseToken(pathArr[1])\n    if (purpose < HARDENED) throw new Error('Purpose has to be hardened')\n    const coinType = parseToken(pathArr[2])\n    if (coinType < HARDENED) throw new Error('Coin Type has to be hardened')\n    const account = parseToken(pathArr[3])\n    if (account < HARDENED) throw new Error('Account has to be hardened')\n    const change = parseToken(pathArr[4])\n    if (change !== 0 && change !== 1) throw new Error('Unknown chain')\n    const index = parseToken(pathArr[5])\n    if (index >= HARDENED) throw new Error('Index should not be hardened')\n    return { purpose, coinType, account, change, index }\n  }\n}\n\nexport const createPath = (\n  account: number = 0,\n  parent: HDPath = { path: ['m'] },\n  hardened?: boolean\n): HDPath => {\n  const { chain = 'external', scriptType = 'P2PKH' } = parent\n\n  const accountStr = `${account}${hardened ? \"'\" : ''}`\n  const index = chain === 'external' ? '0' : '1'\n  const path = [...parent.path, accountStr, index]\n\n  return { path, chain, scriptType }\n}\n\nexport const createPaths = (\n  purpose?: number | Array<number>,\n  coinType: number = 0,\n  account: number = 0,\n  network: string = 'main'\n): Array<HDPath> => {\n  if (Array.isArray(purpose)) {\n    const paths = []\n    for (const p of purpose) {\n      paths.push(...createPaths(p, coinType, account, network))\n    }\n    return paths\n  }\n\n  const { HDPaths, DefaultHDPath } = networks[network]\n  if (!purpose) purpose = DefaultHDPath\n\n  if (purpose === 32) return [createPath(account)]\n\n  const pathSettings = HDPaths[`${purpose}`]\n  if (!pathSettings) throw new Error(`Unknown derivation purpose ${purpose}`)\n\n  const { scriptType } = pathSettings\n  const path = ['m', `${purpose}'`, `${coinType || 0}'`]\n  const hdPath = { path, scriptType }\n  const hdPathInt = { ...hdPath, chain: 'internal' }\n\n  return [\n    createPath(account, hdPath, true),\n    createPath(account, hdPathInt, true)\n  ]\n}\n","// @flow\n\nimport { toPublic } from '../core/privateKey'\nimport { parseToken } from './path.js'\nimport { type DerivedKeyPair } from '../../types/hd.js'\nimport * as Private from './private.js'\nimport * as Public from './public.js'\n\nexport const deriveKeyPair = async (\n  parentKeys: DerivedKeyPair,\n  indexStr?: string = '0'\n): Promise<DerivedKeyPair> => {\n  const hardened = indexStr[indexStr.length - 1] === \"'\"\n  const index = parseToken(indexStr)\n  const { chainCode, privateKey, publicKey } = parentKeys\n\n  if (privateKey) {\n    const childKey = await Private.derive(\n      privateKey,\n      index,\n      chainCode,\n      hardened,\n      publicKey\n    )\n    const childPublicKey = await toPublic(childKey.privateKey, true)\n    return { ...childKey, publicKey: childPublicKey }\n  } else {\n    const childKey = await Public.derive(publicKey, index, chainCode)\n    return { ...childKey }\n  }\n}\n","// @flow\n\nimport {\n  type DerivedKeyPair,\n  type ExtendedKeyPair\n} from '../../types/hd.js'\nimport { toPublic } from '../core/privateKey.js'\nimport {\n  getDecoder,\n  getHDSetting\n} from '../core/networkInfo.js'\nimport { hash160 } from '../utils/hash.js'\nimport { deriveKeyPair } from './derive.js'\n// import * as Private from './private.js'\n// import * as Public from './public.js'\n\nconst MAX_DEPTH = 0xff\n\nexport const fromIndex = async (\n  parentKeys: ExtendedKeyPair,\n  index: string\n): Promise<ExtendedKeyPair> => {\n  if (parentKeys.depth >= MAX_DEPTH) throw new Error('Depth too high.')\n  // result\n  // let result\n  // if (parentKeys.privateKey) {\n  //   result = Private.derive(parentKeys.privateKey, index, )\n  // }\n  const derivedKeyPair: DerivedKeyPair = await deriveKeyPair(parentKeys, index)\n  if (!parentKeys.publicKey) {\n    if (!parentKeys.privateKey) {\n      throw new Error('Cannot create parentFingerPrint without keys')\n    }\n    parentKeys.publicKey = await toPublic(parentKeys.privateKey, true)\n  }\n  const parentFingerPrint = await hash160(parentKeys.publicKey)\n\n  return {\n    ...derivedKeyPair,\n    parentFingerPrint: parseInt(parentFingerPrint.slice(0, 8), 16),\n    version: parentKeys.version,\n    depth: parentKeys.depth + 1\n  }\n}\n\nexport const fromHex = (keyHex: string, network?: string): ExtendedKeyPair => {\n  // Check the entire hex length\n  if (keyHex.length !== 156) throw new Error('Wrong pair length')\n\n  // Check that the key prefix matches the network's prefix if given or any network if not\n  const version = parseInt(keyHex.slice(0, 8), 16)\n  const { xpriv, xpub } = getHDSetting(version, network)\n\n  // Get the byte which tells us what type of key we're expecting\n  const headerByte = parseInt(keyHex.slice(90, 92), 16)\n\n  const key = {}\n\n  if (headerByte === 0 && version === xpriv.prefix) {\n    key.privateKey = keyHex.slice(92, 156)\n  } else if (\n    (headerByte === 2 || headerByte === 3) &&\n    version === xpub.prefix\n  ) {\n    key.publicKey = keyHex.slice(90, 156)\n  } else {\n    throw new Error('Bad key prefix')\n  }\n\n  return {\n    ...key,\n    version,\n    depth: parseInt(keyHex.slice(9, 10), 16),\n    parentFingerPrint: parseInt(keyHex.slice(10, 18), 16),\n    childNumber: parseInt(keyHex.slice(18, 26), 16),\n    chainCode: keyHex.slice(26, 90)\n  }\n}\n\nexport const fromString = (\n  hdKey: string,\n  network: string = 'main'\n): ExtendedKeyPair => {\n  const keyHex = getDecoder(network, hdKey.slice(0, 4)).decode(hdKey)\n  return fromHex(keyHex, network)\n}\n\nexport const toHex = (\n  {\n    depth,\n    parentFingerPrint,\n    childNumber,\n    chainCode,\n    privateKey,\n    publicKey,\n    version\n  }: ExtendedKeyPair,\n  network: string = 'main',\n  forcePublic: boolean = false\n): string => {\n  const { xpub, xpriv } = getHDSetting(version, network)\n\n  let key = publicKey\n  let prefix = xpub.prefix\n\n  if (privateKey && !forcePublic) {\n    key = `00${privateKey}`\n    prefix = xpriv.prefix\n  }\n\n  return (\n    prefix.toString(16).padStart(8, '0') +\n    depth.toString(16).padStart(2, '0') +\n    parentFingerPrint.toString(16).padStart(8, '0') +\n    childNumber.toString(16).padStart(8, '0') +\n    chainCode +\n    key\n  )\n}\n\nexport const toString = (\n  hdKey: ExtendedKeyPair,\n  network: string = 'main',\n  forcePublic: boolean = false\n): string => {\n  const keyHex = toHex(hdKey, network, forcePublic)\n  return getDecoder(network, hdKey.version).encode(keyHex)\n}\n","// @flow\n\nimport { assert } from 'chai'\nimport { describe, it } from 'mocha'\n\nimport * as ExtendedKey from '../../src/hd/extendedKey.js'\nimport fixtures from './fixtures/extendedKey.json'\n\nconst XKeyFixtures = fixtures\nconst network = 'main'\n\ndescribe(`Testing Extended Key functions`, function () {\n  XKeyFixtures.string.forEach(test => {\n    const base58Key = test[0]\n    let xkey = {\n      version: test[2],\n      depth: test[3],\n      parentFingerPrint: test[4],\n      childNumber: test[5],\n      chainCode: test[6]\n    }\n\n    if (test[1].length === 64) xkey = { ...xkey, privateKey: test[1] }\n    if (test[1].length === 66) xkey = { ...xkey, publicKey: test[1] }\n\n    it(`Extended key from string: ${test[0]}`, function () {\n      const resultedXkey = ExtendedKey.fromString(base58Key, network)\n      assert.deepEqual(resultedXkey, xkey)\n    })\n\n    it(`Extended key to string: ${test[1]}`, function () {\n      if (!xkey.publicKey) xkey = { ...xkey, publicKey: `02${test[1]}` }\n      const resultedBase58Key = ExtendedKey.toString(xkey, network)\n      assert.equal(resultedBase58Key, base58Key)\n    })\n  })\n})\n","// @flow\n\nimport {\n  type ExtendedKeyPair,\n  type HDKeyPair,\n  type HDPath,\n  type Index,\n  type Path\n} from '../../types/hd.js'\nimport * as ExtendedKey from './extendedKey.js'\nimport * as Private from './private.js'\n\nexport const fromSeed = async (\n  seed: string,\n  network?: string\n): Promise<HDKeyPair> => {\n  const masterKeyPair = await Private.fromSeed(seed)\n  return {\n    ...masterKeyPair,\n    index: masterKeyPair.childNumber,\n    hardened: false,\n    path: ['m'],\n    children: {}\n  }\n}\n\nexport const fromExtendedKey = (\n  keyPair: ExtendedKeyPair,\n  hdPath?: HDPath\n): HDKeyPair => {\n  const hardened = keyPair.childNumber >= Private.HARDENED\n  const { path: parentPath = [] } = hdPath || {}\n  let indexStr = 'm'\n\n  const path = [...parentPath]\n  if (keyPair.depth) {\n    const adjIndex = hardened ? keyPair.childNumber - Private.HARDENED : keyPair.childNumber\n    indexStr = `${adjIndex}${hardened ? \"'\" : ''}`\n  }\n\n  if (path[0] !== 'm') path.unshift('m')\n  if (path.length === keyPair.depth) {\n    path.push(indexStr)\n  }\n  if (path.length !== keyPair.depth + 1) {\n    throw new Error('Wrong path depth for key')\n  }\n  if (path[path.length - 1] !== indexStr) {\n    throw new Error('Wrong index for key')\n  }\n\n  const hdKey: HDKeyPair = { ...keyPair, path, hardened, children: {} }\n  const { scriptType, chain } = hdPath || {}\n  if (scriptType) hdKey.scriptType = scriptType\n  if (chain) hdKey.chain = chain\n\n  return hdKey\n}\n\nexport const fromIndex = async (\n  parentKey: HDKeyPair,\n  index: Index,\n  network?: string\n): Promise<HDKeyPair> => {\n  // Derive an ExtendedKey key from the current parentKey and index\n  const childKey = await ExtendedKey.fromIndex(parentKey, index)\n  const childHDPath = {\n    ...parentKey,\n    path: [...parentKey.path, index]\n  }\n  // Create an HD key from the ExtendedKey\n  return fromExtendedKey(childKey, childHDPath)\n}\n\nexport const fromPath = async (\n  parentKeys: HDKeyPair,\n  hdPath: HDPath,\n  network?: string\n): Promise<HDKeyPair> => {\n  // Get the deepest possible parent for this key\n  const parent = getParentKey(parentKeys, hdPath.path)\n  // Set the starting derivation key to be the parent key from before\n  let childHDKey = parent.key\n\n  while (parent.path.length) {\n    // Get next child key\n    const index = parent.path.shift()\n    const childKey = await fromIndex(childHDKey, index, network)\n\n    // Add the new key to the current parent key and change the pointer\n    childHDKey.children[index] = childKey\n    childHDKey = childKey\n  }\n\n  // Set the scriptType and chain for the deepest path\n  childHDKey.scriptType = hdPath.scriptType || 'P2PKH'\n  childHDKey.chain = hdPath.chain || 'external'\n\n  return parentKeys\n}\n\nexport const fromPaths = async (\n  parentKey: HDKeyPair | string,\n  hdPaths: Array<HDPath>,\n  network?: string\n): Promise<HDKeyPair> => {\n  // If we get a seed create a master hd key from it\n  if (typeof parentKey === 'string') {\n    parentKey = await fromSeed(parentKey, network)\n  }\n\n  // Create All missing key paths\n  for (const hdPath of hdPaths) {\n    parentKey = await fromPath(parentKey, hdPath)\n  }\n\n  return parentKey\n}\n\nexport const fromString = (\n  extendedKey: string,\n  hdPath?: HDPath,\n  network?: string\n): HDKeyPair => {\n  const keyPair: ExtendedKeyPair = ExtendedKey.fromString(extendedKey, network)\n  return fromExtendedKey(keyPair, hdPath)\n}\n\nexport const getParentKey = (\n  parentKey: HDKeyPair,\n  path: Path\n): { key: HDKeyPair, path: Path } => {\n  const tempPath = [...path]\n  tempPath.shift()\n  while (parentKey.children[tempPath[0]] && tempPath.length) {\n    parentKey = parentKey.children[tempPath.shift()]\n  }\n  return { key: parentKey, path: tempPath }\n}\n\nexport const getKey = (parentKey: HDKeyPair, path: Path): HDKeyPair | null => {\n  const tempPath = [...path]\n  tempPath.shift()\n  while (parentKey && tempPath.length) {\n    parentKey = parentKey.children[tempPath.shift()]\n  }\n  return parentKey\n}\n\nexport const toString = ExtendedKey.toString\n","// @flow\n\nimport { assert } from 'chai'\nimport { describe, it } from 'mocha'\n\nimport * as HDKey from '../../src/hd/hdKey.js'\nimport fixtures from './fixtures/hdKey.json'\n\nconst HDKeyFixtures = fixtures\nconst network = 'main'\n\ndescribe('Testing HD Key', function () {\n  HDKeyFixtures.fromSeed.forEach(test => {\n    it(`Creating HD key from phrase ${test[0]}`, async function () {\n      const childKey = await HDKey.fromSeed(test[1])\n      const xkey = HDKey.toString(childKey)\n      assert.deepEqual(xkey, test[2])\n    })\n  })\n  HDKeyFixtures.fromString.forEach(test => {\n    it(`Creating HD key from xkey ${test[0]} with path ${test[1]}`, function () {\n      const opts = {}\n      if (test[1]) opts.path = test[1].split('/')\n      const hdKey = HDKey.fromString(test[0], opts)\n      assert.equal(hdKey.hardened, test[2])\n      assert.equal(hdKey.path.join('/'), test[3])\n    })\n  })\n  HDKeyFixtures.fromStringErrors.forEach(test => {\n    it(`Error on Creating HD key with error type ${test[2]}`, function () {\n      try {\n        HDKey.fromString(test[0], { path: test[1].split('/') })\n      } catch (e) {\n        assert.equal(e.message, test[2])\n      }\n    })\n  })\n  HDKeyFixtures.fromPath.forEach(test => {\n    it(`Deriving HD key from xkey ${test[0]} with path ${\n      test[1]\n    }`, async function () {\n      const path = test[1].split('/')\n      const parentKey = HDKey.fromString(test[0])\n      let hdKey = await HDKey.fromPath(parentKey, { path })\n      path.shift()\n      let testIndex = 2\n      while (path.length) {\n        const index = path.shift()\n        hdKey = hdKey.children[index]\n        const xprivkey = HDKey.toString(hdKey)\n        const xpubkey = HDKey.toString(hdKey, network, true)\n        assert.equal(xprivkey, test[testIndex][0], 'xpriv')\n        assert.equal(xpubkey, test[testIndex][1], 'xpub')\n        testIndex++\n      }\n    })\n  })\n})\n","// @flow\n\nimport { assert } from 'chai'\nimport { describe, it } from 'mocha'\n\nimport * as HDKey from '../../src/hd/hdKey.js'\nimport { createPaths } from '../../src/hd/path.js'\nimport fixtures from './fixtures/path.json'\n\nconst network = 'main'\n\ndescribe('Testing Bip44 HD Key path derivation', function () {\n  fixtures.createPaths.forEach(test => {\n    it(`Deriving HD key ${test[0]} from HD Settings ${\n      test[3]\n    }`, async function () {\n      const parentKey = HDKey.fromString(test[0])\n\n      let account = 0\n      let coinType = 0\n      if (test[1]) {\n        account = test[1][0]\n        coinType = test[1][1]\n      }\n      const hdPaths = createPaths(test[2], coinType, account, 'bitcoin')\n      const hdKey = await HDKey.fromPaths(parentKey, hdPaths, network)\n      let testIndex = 3\n      for (const hdPath of hdPaths) {\n        const key = HDKey.getKey(hdKey, hdPath.path)\n        if (!key) throw new Error('No Key')\n        const xprivkey = HDKey.toString(key)\n        const xpubkey = HDKey.toString(key, network, true)\n        assert.equal(xprivkey, test[testIndex++], 'xpriv')\n        assert.equal(xpubkey, test[testIndex++], 'xpub')\n      }\n    })\n  })\n})\n"],"names":["lazyHandler","activeModule","get","target","prop","receiver","loadedModule","inject","Proxy","args","lazify","unsafeModule","parentModule","injectedModule","loadUnsafe","defaultModule","Object","assign","parentProxy","isHexString","hex","test","toUint8Array","hexString","Error","length","match","bytes","map","byte","parseInt","Uint8Array","fromUint8Array","reduce","str","toString","padStart","hashjs","require","digest","hash","data","uintArray","rawRes","update","resArray","digestHmac","hmac","key","uintKey","hmacHash","sha256","ripemd160","sha512Hmac","sha512","hash256","hash160","hmacSplit","left","slice","right","ALPHABETS","createCheckSumBase","base","hashFunc","encode","hexStr","checksum","checkHex","decode","baseString","payload","newChecksum","startsWith","createHexEncoder","newBase","a","Buffer","from","check","decoders","alphabet","baseDecoder","basex","bech32","base58","BasePath","scriptType","xpriv","prefix","stringPrefix","decoder","xpub","address","SupportedPaths","main","coinType","wif","HDPaths","Paths","DefaultHDPath","txHash","sigHash","testnet","createInfo","info","newNetwork","set","mainSet","infoSet","Array","isArray","concat","filter","v","i","s","indexOf","createNetworks","newInfos","networks","network","infos","networkType","partialInfo","name","toLowerCase","Networks","getHDSetting","value","e","purpose","hdPath","setting","find","getDecoder","formatFunction","func","opts","numParams","encoder","results","sync","input","output","cps","newCps","p","paramEncoder","encodeResult","res","param","waitResult","params","result","secp256k1","publicKeyCreate","signatureNormalize","signatureExport","privateKeyTweakAdd","publicKeyTweakAdd","verify","signature","sign","toPublic","privateKey","compress","HARDENED","MAX_INDEX","TWEAK_OUT_OF_RANGE_ERROR","SEED","getTweak","chainCode","index","fromSeed","seed","version","publicKey","childNumber","parentFingerPrint","depth","derive","hardened","childKey","message","includes","deriveFixtures","fixtures","describe","private","forEach","it","expectedChildKey","Private","assert","deepEqual","privateWithPublic","public","Public","parseToken","token","num","createPath","account","parent","path","chain","accountStr","createPaths","paths","push","pathSettings","hdPathInt","deriveKeyPair","parentKeys","indexStr","childPublicKey","MAX_DEPTH","fromIndex","derivedKeyPair","fromHex","keyHex","headerByte","fromString","hdKey","toHex","forcePublic","XKeyFixtures","string","base58Key","xkey","resultedXkey","ExtendedKey","resultedBase58Key","equal","masterKeyPair","children","fromExtendedKey","keyPair","parentPath","adjIndex","unshift","parentKey","childHDPath","fromPath","getParentKey","childHDKey","shift","fromPaths","hdPaths","extendedKey","tempPath","getKey","HDKeyFixtures","HDKey","split","join","fromStringErrors","testIndex","xprivkey","xpubkey"],"mappings":"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"}